import React from 'react';

const Blog = () => {
    return (
        <div className=''>
            <div className='background-color text-center pb-28 pt-12'>
                <h2 className='text-[#1A1919] font-bold text-3xl lg:text-5xl'>Here is some questions and answers</h2>
            </div>
            <div className='lg:px-36 px-2 my-10'>
                <h2 className='text-color mt-10 text-2xl lg:text-4xl font-bold'>Q1: When should you use context API?</h2>
                <p className='text-[#1A1919] mt-4 font-bold text-xl lg:text-2xl'>Answer: <span className='text-[#757575] mt-3 text-lg font-semibold'>We will use context API when we need to share state between lot's of components with a lot of nesting. Sometimes, the data you have in one component will only be relevant to its children, so passing it in props is more indicative and nicer. That's why we use context API. It will clean our code also. <br /> Actually, When you need to pass down data or functions through multiple levels of nested components, but some of the intermediate components do not actually use that data or function, using the Context API can help you avoid "prop drilling". Prop drilling can make your code harder to maintain and update, and the Context API provides a more elegant solution by allowing you to share data or functions directly between components without having to pass them through every level of nesting.</span></p>
                <h2 className='text-color mt-10 text-2xl lg:text-4xl font-bold'>Q2: What is a custom hook?</h2>
                <p className='text-[#1A1919] mt-4 font-bold text-xl lg:text-2xl'>Answer: <span className='text-[#757575] mt-3 text-lg font-semibold'>A custom hook in React is a JavaScript function that allows you to encapsulate and reuse logic related to state management, side effects, or other functionality in functional components. Custom hooks are a way to abstract complex logic from components and promote code reusability, maintainability, and readability. <br />Custom hooks follow a specific naming convention, where the name of the hook starts with the prefix "use". For example, you could create a custom hook called "useCounter" to manage counter-related logic, or "useFetch" to handle data fetching operations. Custom hooks can be used in functional components just like any other hook provided by React, such as useState, useEffect, or useContext.</span></p>
                <h2 className='text-color mt-10 text-2xl lg:text-4xl font-bold'>Q3: What is useRef?</h2>
                <p className='text-[#1A1919] mt-4 font-bold text-xl lg:text-2xl'>Answer: <span className='text-[#757575] mt-3 text-lg font-semibold'>useRef() only returns one item. It returns an Object called current . <br /> useRef is a hook provided by React that allows you to create a mutable reference to a value or a DOM element in a functional component. The useRef hook returns an object with a .current property that holds the mutable value or DOM element, and this value persists across multiple renders of the component. <br />The useRef hook is often used for accessing and manipulating DOM elements directly in functional components, as well as for storing and preserving values between renders without triggering re-renders. <br />useRef can also be used to store and preserve values between renders, without triggering re-renders. This can be useful in scenarios where you need to maintain a value across renders, but you don't want changes to that value to trigger re-renders of the component.</span></p>
                <h2 className='text-color mt-10 text-2xl lg:text-4xl font-bold'>Q4: What is useMemo?</h2>
                <p className='text-[#1A1919] mt-4 font-bold text-xl lg:text-2xl'>Answer: <span className='text-[#757575] mt-3 text-lg font-semibold'>useMemo is a React Hook that lets you cache the result of a calculation between re-renders. useMemo is a hook provided by React that allows you to memoize the result of a computation and only recompute it when the dependencies change. This can help optimize performance in React applications by preventing unnecessary calculations and re-renders of components. <br />useMemo is particularly useful in scenarios where the computation of a value is expensive in terms of computation time or resources, and you want to avoid recalculating it on every render. By memoizing the result of the computation and providing a dependencies array, you can ensure that the computation is only performed when necessary, optimizing performance.</span></p>
            </div>
        </div>
    );
};

export default Blog;